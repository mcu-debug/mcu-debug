{
  "version": 3,
  "sources": ["../src/index.ts", "../src/find-free-ports.ts", "../src/command-exists.ts", "../src/handles.ts"],
  "sourcesContent": ["export * from \"./find-free-ports\";\nexport * from \"./command-exists\";\nexport * from \"./handles\";\n", "import * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as os from \"os\";\nimport * as net from \"net\";\nimport * as lockfile from \"proper-lockfile\";\nimport { EventEmitter } from \"events\";\n\nclass PortRangeLock {\n    constructor(\n        private lockPaths: string[],\n        public readonly ports: number[],\n    ) {}\n\n    async release(): Promise<void> {\n        await Promise.all(this.lockPaths.map((p) => lockfile.unlock(p).catch(() => {})));\n    }\n}\n\ninterface findFreePortsOptions {\n    start?: number;\n    consecutive?: boolean;\n    avoid?: Set<number>;\n}\n\nconst allLockFiles: PortRangeLock[] = [];\n\nexport class TcpPortScanner {\n    public static readonly LoopbackAddr = \"127.0.0.1\";\n    public static readonly AllInterfaces = \"0.0.0.0\";\n\n    public static PortAllocated: EventEmitter = new EventEmitter();\n    // Anything allocated using findFreePorts() is added into this set. Never cleared but clients can feel free to clear\n    // findFreePorts() will avoid these ports\n    public static AvoidPorts: Set<number> = new Set<number>();\n\n    public static EmitAllocated(ports: number[]) {\n        if (ports && ports.length) {\n            for (const p of ports) {\n                TcpPortScanner.AvoidPorts.add(p);\n            }\n            TcpPortScanner.PortAllocated.emit(\"allocated\", ports);\n        }\n    }\n\n    /**\n     * Checks to see if the port is in use by creating a server on that port. You should use the function\n     * `isPortInUseEx()` if you want to do a more exhaustive check or a general purpose use for any host\n     *\n     * @param port port to use. Must be > 0 and <= 65535\n     * @param host host ip address to use. This should be an alias to a localhost. (Default: 0.0.0.0 covers all interfaces)\n     * @param avoid if port is in this list, it is considered \"in use\"\n     * @returns Promise that resolves to true if the port is in use, false otherwise\n     */\n    public static isPortInUse(port: number, avoid: Set<number> | undefined): Promise<boolean> {\n        return new Promise((resolve, reject) => {\n            if (avoid && avoid.has(port)) {\n                resolve(true);\n                return;\n            }\n            const server = net.createServer();\n\n            server.once(\"error\", (err: { code?: string }) => {\n                if (err.code === \"EADDRINUSE\") {\n                    // Port is in use on the specified host\n                    resolve(true);\n                } else {\n                    // Other error (e.g., permission denied)\n                    reject(err);\n                }\n            });\n\n            server.once(\"listening\", () => {\n                // Port is available, close the server and resolve to false\n                server.close(() => {\n                    resolve(false);\n                });\n            });\n\n            server.listen(port, TcpPortScanner.AllInterfaces);\n        });\n    }\n\n    /**\n     * Scan for free ports (no one listening) on the specified host.\n     * Don't like the interface but trying to keep compatibility with `portastic.find()`. Unlike\n     * `portastic` the default ports to retrieve is 1 and we also have the option of returning\n     * consecutive ports\n     *\n     * Detail: While this function is async, promises are chained to find open ports recursively\n     *\n     * @param0\n     * @param host Use any string that is a valid host name or ip address\n     * @return a Promise with an array of ports or null when cb is used\n     */\n    public static findFreePorts(numPorts: number, options: findFreePortsOptions = {}): Promise<number[]> {\n        return new Promise<number[]>((resolve, reject) => {\n            findAvailablePortRange(numPorts, options.start ?? 30000, options.consecutive ?? false, options.avoid)\n                .then((lock) => {\n                    allLockFiles.push(lock);\n                    resolve(lock.ports);\n                })\n                .catch((err) => {\n                    reject(err);\n                });\n        });\n    }\n}\n\nasync function tryReserveRange(start: number, count: number, consecutive = false, avoid: Set<number> | undefined): Promise<PortRangeLock | null> {\n    const lockPaths: string[] = [];\n    const ports: number[] = [];\n\n    try {\n        for (let i = 0; ports.length < count; i++) {\n            const port = start + i;\n            const lockPath = path.join(os.tmpdir(), `mcu-debug-port-${port}.lock`);\n\n            const inUse = await TcpPortScanner.isPortInUse(port, avoid);\n            if (inUse) {\n                if (consecutive) {\n                    throw new Error(`Port ${port} is already in use`);\n                } else {\n                    continue;\n                }\n            }\n\n            // Ensure file exists\n            if (!fs.existsSync(lockPath)) {\n                fs.writeFileSync(lockPath, \"\");\n            }\n\n            // Try to lock (non-blocking)\n            await lockfile.lock(lockPath, {\n                retries: 0, // Fail immediately\n                stale: 60000, // 60 second stale timeout\n                realpath: false, // Don't resolve symlinks\n                fs: {\n                    // Custom FS options\n                    retries: 0, // Don't retry FS operations\n                },\n            });\n\n            lockPaths.push(lockPath);\n            ports.push(port);\n        }\n\n        return new PortRangeLock(lockPaths, ports);\n    } catch (err) {\n        // Cleanup locks we got\n        await Promise.all(lockPaths.map((p) => lockfile.unlock(p).catch(() => {})));\n        return null;\n    }\n}\n\nexport async function findAvailablePortRange(count: number, preferredStart: number, consecutive: boolean, avoid: Set<number> | undefined): Promise<PortRangeLock> {\n    for (let base = preferredStart ?? 30000; base < 65535; base += 10) {\n        const result = await tryReserveRange(base, count, consecutive, avoid);\n        if (result) return result;\n    }\n\n    throw new Error(`Could not find ${count} consecutive free ports`);\n}\n\nprocess.on(\"exit\", async () => {\n    for (const lock of allLockFiles) {\n        try {\n            await lock.release();\n        } catch {\n            // Ignore\n        }\n    }\n});\n", "const fs = require(\"fs\");\nconst path = require(\"path\");\nconst process = require(\"process\");\n\nexport function commandExists(commandName: string) {\n    const envPath = process.env.PATH || \"\";\n    // Split the PATH into individual directory paths, considering platform differences\n    const pathDirs = envPath.split(path.delimiter);\n\n    // Define executable extensions for Windows\n    const extensions = process.platform === \"win32\" ? [\".exe\", \".cmd\", \".bat\", \".sh\"] : [\"\"];\n\n    for (const dir of pathDirs) {\n        for (const ext of extensions) {\n            const fullPath = path.join(dir, commandName + ext);\n            try {\n                // Check if the file exists and is executable\n                fs.accessSync(fullPath, fs.constants.F_OK | fs.constants.X_OK);\n                return true; // Command found and is executable\n            } catch (err) {\n                // Command not found or not executable in this specific path/extension combination\n                continue;\n            }\n        }\n    }\n\n    return false; // Command not found anywhere in the PATH\n}\n", "/**\n * Interface for objects that can generate their own unique content-based key.\n */\nexport interface IValueIdentifiable {\n    /**\n     * Returns a string representation that uniquely identifies the value\n     * of this object. (e.g. \"User:123:v1\")\n     */\n    toValueKey(): string;\n}\n\n/**\n * A registry that assigns a unique integer handle to objects based on\n * their structural value (deep equality) rather than reference.\n *\n * Note: Can be Expensive. The default implementation uses a stable\n * JSON.stringify to determine object equality. For better performance,\n * objects can implement IValueIdentifiable to provide their own\n * unique value-based key.\n *\n * Usage:\n *   const registry = new ValueHandleRegistry<MyType>();\n *   const handle = registry.getHandle(myObject);\n *   const sameHandle = registry.getHandle(anotherObjectWithSameValue);\n *   const originalObject = registry.getObject(handle);\n */\n\nexport class ValueHandleRegistry<T = any> {\n    private keyToHandle = new Map<string, number>();\n    private handleToObj = new Map<number, T>();\n    private counter = 0;\n\n    /**\n     * Get a handle for an object. If the object (by value) has been seen before,\n     * returns the existing handle. Otherwise, creates a new one.\n     */\n    public addObject(obj: T): number {\n        const key = this.getKey(obj);\n\n        let handle = this.keyToHandle.get(key);\n        if (handle !== undefined) {\n            return handle;\n        }\n\n        handle = ++this.counter;\n        this.keyToHandle.set(key, handle);\n        this.handleToObj.set(handle, obj);\n        return handle;\n    }\n\n    public getHandle(obj: T): number | undefined {\n        const key = this.getKey(obj);\n        const handle = this.keyToHandle.get(key);\n        return handle;\n    }\n\n    public getObject(handle: number): T | undefined {\n        return this.handleToObj.get(handle);\n    }\n\n    public getObjectByKey(key: T): T | undefined {\n        const handle = this.keyToHandle.get(this.getKey(key));\n        if (handle !== undefined) {\n            return this.handleToObj.get(handle);\n        }\n        return undefined;\n    }\n\n    public release(handle: number): boolean {\n        const obj = this.handleToObj.get(handle);\n        if (!obj) return false;\n\n        const key = this.getKey(obj);\n        this.keyToHandle.delete(key);\n        this.handleToObj.delete(handle);\n        return true;\n    }\n\n    /**\n     * Determines the unique key for an object using the hybrid strategy.\n     */\n    private getKey(obj: any): string {\n        // 1. Optimization: Check if object generates its own key\n        if (isValueIdentifiable(obj)) {\n            return obj.toValueKey();\n        }\n        // 2. Fallback: Structural equality\n        return this.stableStringify(obj);\n    }\n\n    /**\n     * Recursively stringifies an object with sorted keys.\n     * Respects IValueIdentifiable during recursion.\n     */\n    private stableStringify(val: any): string {\n        // Check for Interface deep in the tree\n        if (isValueIdentifiable(val)) {\n            return val.toValueKey();\n        }\n\n        // Primitives / Null\n        if (val === null || typeof val !== \"object\") {\n            return JSON.stringify(val);\n        }\n\n        // Native Types that don't serialize well with Object.keys()\n        if (val instanceof Date) return JSON.stringify(val.toISOString());\n        if (val instanceof RegExp) return JSON.stringify(val.toString());\n\n        // Arrays\n        if (Array.isArray(val)) {\n            return \"[\" + val.map((item) => this.stableStringify(item)).join(\",\") + \"]\";\n        }\n\n        // Objects: Sort keys for determinism\n        const keys = Object.keys(val).sort();\n        const parts = keys.map((key) => {\n            return JSON.stringify(key) + \":\" + this.stableStringify(val[key]);\n        });\n\n        return \"{\" + parts.join(\",\") + \"}\";\n    }\n\n    public clear() {\n        this.keyToHandle.clear();\n        this.handleToObj.clear();\n        this.counter = 0;\n    }\n}\n\n// Type Guard: safely checks if an object implements the interface\nfunction isValueIdentifiable(obj: any): obj is IValueIdentifiable {\n    return obj && typeof obj.toValueKey === \"function\";\n}\n\nexport class ValueHandleRegistryPrimitive<T = string | number | boolean | BigInt> {\n    private keyToHandle = new Map<T, number>();\n    private handleToItem = new Map<number, T>();\n    private counter = 0;\n\n    add(item: T): number {\n        this.counter++;\n\n        this.keyToHandle.set(item, this.counter);\n        this.handleToItem.set(this.counter, item);\n        return this.counter;\n    }\n\n    getObject(handle: number): T | undefined {\n        return this.handleToItem.get(handle);\n    }\n\n    release(handle: number): boolean {\n        const obj = this.handleToItem.get(handle);\n        if (!obj) return false;\n\n        this.keyToHandle.delete(obj);\n        this.handleToItem.delete(handle);\n        return true;\n    }\n\n    clear() {\n        this.keyToHandle.clear();\n        this.handleToItem.clear();\n        this.counter = 0;\n    }\n}\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "TcpPortScanner", "ValueHandleRegistry", "ValueHandleRegistryPrimitive", "commandExists", "findAvailablePortRange", "__toCommonJS", "fs", "path", "os", "net", "lockfile", "import_events", "PortRangeLock", "lockPaths", "ports", "p", "allLockFiles", "TcpPortScanner", "_TcpPortScanner", "port", "avoid", "resolve", "reject", "server", "err", "numPorts", "options", "findAvailablePortRange", "lock", "tryReserveRange", "start", "count", "consecutive", "i", "lockPath", "preferredStart", "base", "result", "fs", "path", "process", "commandExists", "commandName", "pathDirs", "extensions", "dir", "ext", "fullPath", "ValueHandleRegistry", "obj", "key", "handle", "isValueIdentifiable", "val", "item", "ValueHandleRegistryPrimitive"]
}
