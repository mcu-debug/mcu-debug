{
  "version": 3,
  "sources": ["../src/index.ts", "../src/find-free-ports.ts", "../src/command-exists.ts", "../src/handles.ts", "../src/wait-for-port.ts"],
  "sourcesContent": ["export * from \"./find-free-ports\";\nexport * from \"./command-exists\";\nexport * from \"./handles\";\nexport * from \"./wait-for-port\";\n", "import * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as os from \"os\";\nimport * as net from \"net\";\nimport * as lockfile from \"proper-lockfile\";\nimport { EventEmitter } from \"events\";\n\nclass PortRangeLock {\n    constructor(\n        private lockPaths: string[],\n        public readonly ports: number[],\n    ) {}\n\n    async release(): Promise<void> {\n        await Promise.all(this.lockPaths.map((p) => lockfile.unlock(p).catch(() => {})));\n    }\n}\n\ninterface findFreePortsOptions {\n    start?: number;\n    consecutive?: boolean;\n    avoid?: Set<number>;\n}\n\nconst allLockFiles: PortRangeLock[] = [];\n\nexport class TcpPortScanner {\n    public static readonly LoopbackAddr = \"127.0.0.1\";\n    public static readonly AllInterfaces = \"0.0.0.0\";\n\n    public static PortAllocated: EventEmitter = new EventEmitter();\n    // Anything allocated using findFreePorts() is added into this set. Never cleared but clients can feel free to clear\n    // findFreePorts() will avoid these ports\n    public static AvoidPorts: Set<number> = new Set<number>();\n\n    public static EmitAllocated(ports: number[]) {\n        if (ports && ports.length) {\n            for (const p of ports) {\n                TcpPortScanner.AvoidPorts.add(p);\n            }\n            TcpPortScanner.PortAllocated.emit(\"allocated\", ports);\n        }\n    }\n\n    /**\n     * Checks to see if the port is in use by creating a server on that port. You should use the function\n     * `isPortInUseEx()` if you want to do a more exhaustive check or a general purpose use for any host\n     *\n     * @param port port to use. Must be > 0 and <= 65535\n     * @param host host ip address(es) to use. This should be an alias to a localhost. (Default: check both 127.0.0.1\n     * and 0.0.0.0 covers all interfaces -- needed for macOS)\n     * @param avoid if port is in this list, it is considered \"in use\"\n     * @returns Promise that resolves to true if the port is in use, false otherwise\n     */\n    public static async isPortInUse(port: number, avoid: Set<number> | undefined, hosts?: string[]): Promise<boolean> {\n        if (avoid && avoid.has(port)) {\n            return true;\n        }\n\n        // If a specific host is requested, check only that.\n        // Otherwise, check both 127.0.0.1 and 0.0.0.0 to be safe across platforms (e.g. macOS vs Linux)\n        const hostsToCheck = hosts && hosts.length ? hosts : [TcpPortScanner.LoopbackAddr, TcpPortScanner.AllInterfaces];\n\n        for (const h of hostsToCheck) {\n            const inUse = await TcpPortScanner.checkPortStatus(port, h);\n            if (inUse) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private static checkPortStatus(port: number, host: string): Promise<boolean> {\n        return new Promise((resolve, reject) => {\n            const server = net.createServer(() => {\n                // We should not get here\n            });\n\n            server.once(\"error\", (err: { code?: string }) => {\n                if (err.code === \"EADDRINUSE\") {\n                    // Port is in use on the specified host\n                    resolve(true);\n                } else {\n                    // Other error (e.g., permission denied)\n                    reject(err);\n                }\n            });\n\n            server.once(\"close\", () => {\n                resolve(false);\n            });\n\n            server.listen(port, host, () => {\n                server.close();\n            });\n        });\n    }\n\n    /**\n     * Scan for free ports (no one listening) on the specified host.\n     * Don't like the interface but trying to keep compatibility with `portastic.find()`. Unlike\n     * `portastic` the default ports to retrieve is 1 and we also have the option of returning\n     * consecutive ports\n     *\n     * Detail: While this function is async, promises are chained to find open ports recursively\n     *\n     * @param0\n     * @param host Use any string that is a valid host name or ip address\n     * @return a Promise with an array of ports or null when cb is used\n     */\n    public static findFreePorts(numPorts: number, options: findFreePortsOptions = {}): Promise<number[]> {\n        return new Promise<number[]>((resolve, reject) => {\n            findAvailablePortRange(numPorts, options.start ?? 30000, options.consecutive ?? false, options.avoid)\n                .then((lock) => {\n                    allLockFiles.push(lock);\n                    resolve(lock.ports);\n                })\n                .catch((err) => {\n                    reject(err);\n                });\n        });\n    }\n}\n\nasync function tryReserveRange(start: number, count: number, consecutive = false, avoid: Set<number> | undefined): Promise<PortRangeLock | null> {\n    const ports: number[] = [];\n    const lockPaths: string[] = [];\n    const releaseLocks: (() => Promise<void>)[] = [];\n\n    try {\n        for (let i = 0; ports.length < count; i++) {\n            const port = start + i;\n            if (port > 65535) {\n                throw new Error(\"Out of ports\");\n            }\n\n            const lockPath = path.join(os.tmpdir(), `mcu-debug-port-${port}.lock`);\n\n            const inUse = await TcpPortScanner.isPortInUse(port, avoid);\n            if (inUse) {\n                if (consecutive) {\n                    throw new Error(`Port ${port} is already in use`);\n                } else {\n                    continue;\n                }\n            }\n\n            try {\n                // Ensure file exists\n                if (!fs.existsSync(lockPath)) {\n                    fs.writeFileSync(lockPath, \"\");\n                }\n\n                const release = await lockfile.lock(lockPath, { stale: 30000 });\n\n                lockPaths.push(lockPath);\n                releaseLocks.push(release);\n                ports.push(port);\n            } catch (e) {\n                if (consecutive) {\n                    throw e;\n                }\n                // If not consecutive, just treat this port as unavailable and continue\n                continue;\n            }\n        }\n\n        return new PortRangeLock(lockPaths, ports);\n    } catch (err) {\n        // Cleanup locks we got\n        try {\n            await Promise.all(releaseLocks.map((r) => r().catch(() => {})));\n        } catch (e: any) {\n            console.error(`Error releasing port locks: ${e.toString()}`);\n        }\n        return null;\n    }\n}\n\nexport async function findAvailablePortRange(count: number, preferredStart: number, consecutive: boolean, avoid: Set<number> | undefined): Promise<PortRangeLock> {\n    for (let base = preferredStart ?? 30000; base < 65535; base += 10) {\n        const result = await tryReserveRange(base, count, consecutive, avoid);\n        if (result) return result;\n    }\n\n    throw new Error(`Could not find ${count} consecutive free ports`);\n}\n\nprocess.on(\"exit\", async () => {\n    for (const lock of allLockFiles) {\n        try {\n            await lock.release();\n        } catch {\n            // Ignore\n        }\n    }\n});\n", "const fs = require(\"fs\");\nconst path = require(\"path\");\nconst process = require(\"process\");\n\nexport function commandExists(commandName: string) {\n    const envPath = process.env.PATH || \"\";\n    // Split the PATH into individual directory paths, considering platform differences\n    const pathDirs = envPath.split(path.delimiter);\n\n    // Define executable extensions for Windows\n    const extensions = process.platform === \"win32\" ? [\".exe\", \".cmd\", \".bat\", \".sh\"] : [\"\"];\n\n    for (const dir of pathDirs) {\n        for (const ext of extensions) {\n            const fullPath = path.join(dir, commandName + ext);\n            try {\n                // Check if the file exists and is executable\n                fs.accessSync(fullPath, fs.constants.F_OK | fs.constants.X_OK);\n                return true; // Command found and is executable\n            } catch (err) {\n                // Command not found or not executable in this specific path/extension combination\n                continue;\n            }\n        }\n    }\n\n    return false; // Command not found anywhere in the PATH\n}\n", "/**\n * Interface for objects that can generate their own unique content-based key.\n */\nexport interface IValueIdentifiable {\n    /**\n     * Returns a string representation that uniquely identifies the value\n     * of this object. (e.g. \"User:123:v1\")\n     */\n    toValueKey(): string;\n}\n\n/**\n * A registry that assigns a unique integer handle to objects based on\n * their structural value (deep equality) rather than reference.\n *\n * Note: Can be Expensive. The default implementation uses a stable\n * JSON.stringify to determine object equality. For better performance,\n * objects can implement IValueIdentifiable to provide their own\n * unique value-based key.\n *\n * Usage:\n *   const registry = new ValueHandleRegistry<MyType>();\n *   const handle = registry.getHandle(myObject);\n *   const sameHandle = registry.getHandle(anotherObjectWithSameValue);\n *   const originalObject = registry.getObject(handle);\n */\n\nexport class ValueHandleRegistry<T = any> {\n    private keyToHandle = new Map<string, number>();\n    private handleToObj = new Map<number, T>();\n    private counter = 0;\n\n    /**\n     * Get a handle for an object. If the object (by value) has been seen before,\n     * returns the existing handle. Otherwise, creates a new one.\n     */\n    public addObject(obj: T): number {\n        const key = this.getKey(obj);\n\n        let handle = this.keyToHandle.get(key);\n        if (handle !== undefined) {\n            return handle;\n        }\n\n        handle = ++this.counter;\n        this.keyToHandle.set(key, handle);\n        this.handleToObj.set(handle, obj);\n        return handle;\n    }\n\n    public getHandle(obj: T): number | undefined {\n        const key = this.getKey(obj);\n        const handle = this.keyToHandle.get(key);\n        return handle;\n    }\n\n    public getObject(handle: number): T | undefined {\n        return this.handleToObj.get(handle);\n    }\n\n    public getObjectByKey(key: T): T | undefined {\n        const k = this.getKey(key);\n        const handle = this.keyToHandle.get(k);\n        if (handle !== undefined) {\n            return this.handleToObj.get(handle);\n        }\n        return undefined;\n    }\n\n    public release(handle: number): boolean {\n        const obj = this.handleToObj.get(handle);\n        if (!obj) return false;\n\n        const key = this.getKey(obj);\n        this.keyToHandle.delete(key);\n        this.handleToObj.delete(handle);\n        return true;\n    }\n\n    /**\n     * Determines the unique key for an object using the hybrid strategy.\n     */\n    private getKey(obj: any): string {\n        // 1. Optimization: Check if object generates its own key\n        if (isValueIdentifiable(obj)) {\n            return obj.toValueKey();\n        }\n        // 2. Fallback: Structural equality\n        return this.stableStringify(obj);\n    }\n\n    /**\n     * Recursively stringifies an object with sorted keys.\n     * Respects IValueIdentifiable during recursion.\n     */\n    private stableStringify(val: any): string {\n        // Check for Interface deep in the tree\n        if (isValueIdentifiable(val)) {\n            return val.toValueKey();\n        }\n\n        // Primitives / Null\n        if (val === null || typeof val !== \"object\") {\n            return JSON.stringify(val);\n        }\n\n        // Native Types that don't serialize well with Object.keys()\n        if (val instanceof Date) return JSON.stringify(val.toISOString());\n        if (val instanceof RegExp) return JSON.stringify(val.toString());\n\n        // Arrays\n        if (Array.isArray(val)) {\n            return \"[\" + val.map((item) => this.stableStringify(item)).join(\",\") + \"]\";\n        }\n\n        // Objects: Sort keys for determinism\n        const keys = Object.keys(val).sort();\n        const parts = keys.map((key) => {\n            return JSON.stringify(key) + \":\" + this.stableStringify(val[key]);\n        });\n\n        return \"{\" + parts.join(\",\") + \"}\";\n    }\n\n    public clear() {\n        this.keyToHandle.clear();\n        this.handleToObj.clear();\n        this.counter = 0;\n    }\n}\n\n// Type Guard: safely checks if an object implements the interface\nfunction isValueIdentifiable(obj: any): obj is IValueIdentifiable {\n    return obj && typeof obj.toValueKey === \"function\";\n}\n\nexport class ValueHandleRegistryPrimitive<T = string | number | boolean | BigInt> {\n    private keyToHandle = new Map<T, number>();\n    private handleToItem = new Map<number, T>();\n    private counter = 0;\n\n    add(item: T): number {\n        const existing = this.keyToHandle.get(item);\n        if (existing !== undefined) {\n            return existing;\n        }\n        this.counter++;\n        this.keyToHandle.set(item, this.counter);\n        this.handleToItem.set(this.counter, item);\n        return this.counter;\n    }\n\n    get(handle: number): T | undefined {\n        return this.handleToItem.get(handle);\n    }\n\n    release(handle: number): boolean {\n        const obj = this.handleToItem.get(handle);\n        if (!obj) return false;\n\n        this.keyToHandle.delete(obj);\n        this.handleToItem.delete(handle);\n        return true;\n    }\n\n    clear() {\n        this.keyToHandle.clear();\n        this.handleToItem.clear();\n        this.counter = 0;\n    }\n}\n", "import * as net from \"net\";\n\n//\n// This module is a copy of the 'wait-for-port' module from npm, modified to make it TypeScript\n// friendly and expose callbaccks for progress reporting.\n//\n// Also add a proper return object and a way get the created socket\n// to be used later.\n\ninterface WaitForCallbacks {\n    starting: (params: { host: string; port: number }) => void;\n    setup: (socket: net.Socket) => void; // Call this to setup your own socket handlers\n    tryConnect?: () => void;\n    connected: (socket: net.Socket) => void;\n    timeout: () => void;\n}\n\nconst DefaultWaitCallbacks: { [key: string]: WaitForCallbacks } = {\n    silent: {\n        setup: () => {},\n        starting: () => {},\n        tryConnect: () => {},\n        connected: () => {},\n        timeout: () => {},\n    },\n    verbose: {\n        starting: ({ host, port }) => {\n            console.log(`Waiting for ${host}:${port} to become available...`);\n        },\n        setup: (socket: net.Socket) => {\n            console.log(`Socket created: ${socket.remoteAddress}:${socket.remotePort}`);\n        },\n        tryConnect: () => {\n            console.log(\"Trying to connect...\");\n        },\n        connected: (socket: net.Socket) => {\n            console.log(\"Connected!\");\n        },\n        timeout: () => {\n            console.log(\"Timeout reached, giving up.\");\n        },\n    },\n};\n\nexport interface ReturnObject {\n    open: boolean;\n    socket?: net.Socket; // If successful, the created socket\n    ipVersion?: number;\n}\n\nexport interface WaitForPortArgs {\n    protocol: \"tcp\" | \"http\"; // http will do a HTTP GET after connecting. Not fully tested. Sould also include https.\n    host: string;\n    port: number;\n    callbacks: WaitForCallbacks;\n    path?: string;\n    interval?: number;\n    timeout?: number;\n    waitForDns?: boolean;\n}\n\nexport class WaitForPort {\n    IPv6enabled = true;\n    constructor(private params: WaitForPortArgs) {}\n    private returnedSocket = false;\n\n    private createConnectionWithTimeout(ipVersion: number, timeout: number, callback: (err?: Error) => void) {\n        //  Variable to hold the timer we'll use to kill the socket if we don't\n        //  connect in time.\n        let timer: NodeJS.Timeout | null = null;\n\n        //  Try and open the socket, with the params and callback.\n        const opts: net.NetConnectOpts = {\n            host: this.params.host,\n            port: this.params.port,\n            family: ipVersion,\n            autoSelectFamily: true,\n        };\n        const socket = net.createConnection(opts, (err?: Error) => {\n            if (!err && timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            if (!this.returnedSocket) {\n                return callback(err);\n            }\n        });\n\n        // Let the caller setup their own socket handlers\n        this.params.callbacks.setup?.(socket);\n\n        //  TODO: Check for the socket ECONNREFUSED event.\n        socket.on(\"error\", (error) => {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            if (!this.returnedSocket) {\n                socket.destroy();\n                callback(error);\n            }\n        });\n\n        //  Kill the socket if we don't open in time.\n        timer = setTimeout(() => {\n            socket.destroy();\n            const error = new Error(`Timeout trying to open socket to ${this.params.host}:${this.params.port}, IPv${ipVersion}`);\n            (error as any).code = \"ECONNTIMEOUT\";\n            callback(error);\n        }, timeout);\n\n        //  Return the socket.\n        return socket;\n    }\n\n    private checkHttp(socket: net.Socket, ipVersion: number, timeout: number, callback: (err?: Error) => void) {\n        //  Create the HTTP request.\n        const request = `GET ${this.params.path} HTTP/1.1\\r\\nHost: ${this.params.host}\\r\\n\\r\\n`;\n\n        let timer: NodeJS.Timeout | null = null;\n        timer = setTimeout(() => {\n            socket.destroy();\n            const error = new Error(`Timeout waiting for data from ${this.params.host}:${this.params.port}, IPv${ipVersion}`);\n            (error as any).code = \"EREQTIMEOUT\";\n            callback(error);\n        }, timeout);\n\n        //  Get ready for a response.\n        socket.on(\"data\", function (data) {\n            //  Get the response as text.\n            const response = data.toString();\n            const statusLine = response.split(\"\\n\")[0];\n\n            //  Stop the timer.\n            if (timer) clearTimeout(timer);\n\n            //  Check the data. Remember an HTTP response is:\n            //  HTTP/1.1 XXX Stuff\n            const statusLineParts = statusLine.split(\" \");\n            if (statusLineParts.length < 2 || statusLineParts[1].startsWith(\"2\") === false) {\n                const error = new Error(\"Invalid response from server\");\n                (error as any).code = \"ERESPONSE\";\n                callback(error);\n            }\n\n            //  ALL good!\n            callback();\n        });\n\n        //  Send the request.\n        socket.write(request);\n    }\n\n    //  This function attempts to open a connection, given a limited time window.\n    //  This is the function which we will run repeatedly until we connect.\n    private tryConnect(ipVersion: number, timeout: number): Promise<[boolean, net.Socket?]> {\n        return new Promise((resolve, reject) => {\n            try {\n                const socket = this.createConnectionWithTimeout(ipVersion, this.params.interval || 1000, (err: any) => {\n                    if (err) {\n                        if (err.code === \"ECONNREFUSED\" || err.code === \"EACCES\") {\n                            //  We successfully *tried* to connect, so resolve with false so\n                            //  that we try again.\n                            socket.destroy();\n                            return resolve([false]);\n                        } else if (err.code === \"ECONNTIMEOUT\") {\n                            //  We've successfully *tried* to connect, but we're timing out\n                            //  establishing the connection. This is not ideal (either\n                            //  the port is open or it ain't).\n                            socket.destroy();\n                            return resolve([false]);\n                        } else if (err.code === \"ECONNRESET\") {\n                            //  This can happen if the target server kills its connection before\n                            //  we can read from it, we can normally just try again.\n                            socket.destroy();\n                            return resolve([false]);\n                        } else if (this.IPv6enabled === true && (err.code === \"EADDRNOTAVAIL\" || err.code === \"ENOTFOUND\")) {\n                            //  This will occur if the IP address we are trying to connect to does not exist\n                            //  This can happen for ::1 or other IPv6 addresses if the IPv6 stack is not enabled.\n                            //  In this case we disable the IPv6 lookup\n                            this.IPv6enabled = false;\n                            socket.destroy();\n                            return resolve([false]);\n                        } else if (err.code === \"ENOTFOUND\") {\n                            //  This will occur if the address is not found, i.e. due to a dns\n                            //  lookup fail (normally a problem if the domain is wrong).\n                            socket.destroy();\n\n                            //  If we are going to wait for DNS records, we can actually just try\n                            //  again...\n                            if (this.params.waitForDns === true) return resolve([false]);\n\n                            // ...otherwise, we will explicitly fail with a meaningful error for\n                            //  the user.\n                            return reject(new Error(`The address '${this.params.host}' cannot be found`));\n                        }\n\n                        //  Trying to open the socket has resulted in an error we don't\n                        //  understand. Better give up.\n                        socket.destroy();\n\n                        // If we are currently checking for IPv6 we ignore this error and disable IPv6\n                        if (ipVersion === 6) {\n                            this.IPv6enabled = false;\n                            return resolve([false]);\n                        }\n\n                        return reject(err);\n                    }\n\n                    //  Boom, we connected!\n\n                    //  If we are not dealing with http, we're done.\n                    if (this.params.protocol !== \"http\") {\n                        // stop the timer and resolve.\n                        // socket.destroy();\n                        return resolve([true, socket]);\n                    }\n\n                    //  TODO: we should only use the portion of the timeout for this interval which is still left to us.\n\n                    //  Now we've got to wait for a HTTP response.\n                    this.checkHttp(socket, ipVersion, timeout, (err: any) => {\n                        if (err) {\n                            if (err.code === \"EREQTIMEOUT\") {\n                                socket.destroy();\n                                return resolve([false]);\n                            } else if (err.code === \"ERESPONSE\") {\n                                socket.destroy();\n                                return resolve([false]);\n                            }\n                            socket.destroy();\n                            return reject(err);\n                        }\n\n                        // socket.destroy();\n                        return resolve([true, socket]);\n                    });\n                });\n            } catch (err) {\n                //  Trying to open the socket has resulted in an exception we don't\n                //  understand. Better give up.\n                return reject(err);\n            }\n        });\n    }\n\n    public waitPort(): Promise<ReturnObject> {\n        this.returnedSocket = false;\n        this.IPv6enabled = true;\n        return new Promise((resolve, reject) => {\n            validateParameters(this.params);\n\n            const host = this.params.host;\n            const port = this.params.port;\n            const interval = this.params.interval!;\n            const timeout = this.params.timeout!;\n            //  Keep track of the start time (needed for timeout calcs).\n            const startTime = new Date();\n\n            //  Don't wait for more than connectTimeout to try and connect.\n            const connectTimeout = 1000;\n\n            //  Grab the object for output.\n            const outputFunction = this.params.callbacks || DefaultWaitCallbacks.silent;\n            outputFunction.starting({ host, port });\n\n            //  Start trying to connect.\n            const loop = (ipVersion = 4) => {\n                outputFunction.tryConnect?.();\n                this.tryConnect(ipVersion, connectTimeout)\n                    .then(([open, socket]) => {\n                        //  The socket is open, we're done.\n                        if (open) {\n                            this.returnedSocket = true;\n                            outputFunction.connected(socket!);\n                            return resolve({ open: true, ipVersion, socket });\n                        }\n\n                        //  If we have a timeout, and we've passed it, we're done.\n                        const now = new Date();\n                        const delta = now.getTime() - startTime.getTime();\n                        if (timeout && delta > timeout) {\n                            outputFunction.timeout();\n                            return resolve({ open: false });\n                        }\n\n                        // Check for IPv6 next\n                        if (this.IPv6enabled && ipVersion === 4 && !net.isIP(host)) {\n                            return loop(6);\n                        }\n\n                        //  Run the loop again.\n                        return setTimeout(loop, interval);\n                    })\n                    .catch((err) => {\n                        return reject(err);\n                    });\n            };\n\n            //  Start the loop.\n            loop();\n        });\n    }\n}\n\nfunction validateParameters(params: WaitForPortArgs) {\n    params.protocol = params.protocol || \"tcp\";\n    params.host = params.host || \"127.0.0.1\";\n    params.port = params.port || 80;\n    params.path = params.path || \"/\";\n    params.interval = params.interval || 1000;\n    params.timeout = params.timeout || 0;\n    params.waitForDns = params.waitForDns || false;\n}\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "TcpPortScanner", "ValueHandleRegistry", "ValueHandleRegistryPrimitive", "WaitForPort", "commandExists", "findAvailablePortRange", "__toCommonJS", "fs", "path", "os", "net", "lockfile", "import_events", "PortRangeLock", "lockPaths", "ports", "p", "allLockFiles", "TcpPortScanner", "_TcpPortScanner", "port", "avoid", "hosts", "hostsToCheck", "h", "host", "resolve", "reject", "server", "err", "numPorts", "options", "findAvailablePortRange", "lock", "tryReserveRange", "start", "count", "consecutive", "releaseLocks", "i", "lockPath", "release", "e", "r", "preferredStart", "base", "result", "fs", "path", "process", "commandExists", "commandName", "pathDirs", "extensions", "dir", "ext", "fullPath", "ValueHandleRegistry", "obj", "key", "handle", "k", "isValueIdentifiable", "val", "item", "ValueHandleRegistryPrimitive", "existing", "net", "DefaultWaitCallbacks", "host", "port", "socket", "WaitForPort", "params", "ipVersion", "timeout", "callback", "timer", "opts", "err", "error", "request", "data", "statusLine", "statusLineParts", "resolve", "reject", "validateParameters", "interval", "startTime", "connectTimeout", "outputFunction", "loop", "open", "delta"]
}
