{
  "version": 3,
  "sources": ["../src/find-free-ports.ts", "../src/command-exists.ts", "../src/handles.ts"],
  "sourcesContent": ["import * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as os from \"os\";\nimport * as net from \"net\";\nimport * as lockfile from \"proper-lockfile\";\nimport { EventEmitter } from \"events\";\n\nclass PortRangeLock {\n    constructor(\n        private lockPaths: string[],\n        public readonly ports: number[],\n    ) {}\n\n    async release(): Promise<void> {\n        await Promise.all(this.lockPaths.map((p) => lockfile.unlock(p).catch(() => {})));\n    }\n}\n\ninterface findFreePortsOptions {\n    start?: number;\n    consecutive?: boolean;\n    avoid?: Set<number>;\n}\n\nconst allLockFiles: PortRangeLock[] = [];\n\nexport class TcpPortScanner {\n    public static readonly LoopbackAddr = \"127.0.0.1\";\n    public static readonly AllInterfaces = \"0.0.0.0\";\n\n    public static PortAllocated: EventEmitter = new EventEmitter();\n    // Anything allocated using findFreePorts() is added into this set. Never cleared but clients can feel free to clear\n    // findFreePorts() will avoid these ports\n    public static AvoidPorts: Set<number> = new Set<number>();\n\n    public static EmitAllocated(ports: number[]) {\n        if (ports && ports.length) {\n            for (const p of ports) {\n                TcpPortScanner.AvoidPorts.add(p);\n            }\n            TcpPortScanner.PortAllocated.emit(\"allocated\", ports);\n        }\n    }\n\n    /**\n     * Checks to see if the port is in use by creating a server on that port. You should use the function\n     * `isPortInUseEx()` if you want to do a more exhaustive check or a general purpose use for any host\n     *\n     * @param port port to use. Must be > 0 and <= 65535\n     * @param host host ip address(es) to use. This should be an alias to a localhost. (Default: check both 127.0.0.1\n     * and 0.0.0.0 covers all interfaces -- needed for macOS)\n     * @param avoid if port is in this list, it is considered \"in use\"\n     * @returns Promise that resolves to true if the port is in use, false otherwise\n     */\n    public static async isPortInUse(port: number, avoid: Set<number> | undefined, hosts?: string[]): Promise<boolean> {\n        if (avoid && avoid.has(port)) {\n            return true;\n        }\n\n        // If a specific host is requested, check only that.\n        // Otherwise, check both 127.0.0.1 and 0.0.0.0 to be safe across platforms (e.g. macOS vs Linux)\n        const hostsToCheck = hosts && hosts.length ? hosts : [TcpPortScanner.LoopbackAddr, TcpPortScanner.AllInterfaces];\n\n        for (const h of hostsToCheck) {\n            const inUse = await TcpPortScanner.checkPortStatus(port, h);\n            if (inUse) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private static checkPortStatus(port: number, host: string): Promise<boolean> {\n        return new Promise((resolve, reject) => {\n            const server = net.createServer(() => {\n                // We should not get here\n            });\n\n            server.once(\"error\", (err: { code?: string }) => {\n                if (err.code === \"EADDRINUSE\") {\n                    // Port is in use on the specified host\n                    resolve(true);\n                } else {\n                    // Other error (e.g., permission denied)\n                    reject(err);\n                }\n            });\n\n            server.once(\"close\", () => {\n                resolve(false);\n            });\n\n            server.listen(port, host, () => {\n                server.close();\n            });\n        });\n    }\n\n    /**\n     * Scan for free ports (no one listening) on the specified host.\n     * Don't like the interface but trying to keep compatibility with `portastic.find()`. Unlike\n     * `portastic` the default ports to retrieve is 1 and we also have the option of returning\n     * consecutive ports\n     *\n     * Detail: While this function is async, promises are chained to find open ports recursively\n     *\n     * @param0\n     * @param host Use any string that is a valid host name or ip address\n     * @return a Promise with an array of ports or null when cb is used\n     */\n    public static findFreePorts(numPorts: number, options: findFreePortsOptions = {}): Promise<number[]> {\n        return new Promise<number[]>((resolve, reject) => {\n            findAvailablePortRange(numPorts, options.start ?? 30000, options.consecutive ?? false, options.avoid)\n                .then((lock) => {\n                    allLockFiles.push(lock);\n                    resolve(lock.ports);\n                })\n                .catch((err) => {\n                    reject(err);\n                });\n        });\n    }\n}\n\nasync function tryReserveRange(start: number, count: number, consecutive = false, avoid: Set<number> | undefined): Promise<PortRangeLock | null> {\n    const ports: number[] = [];\n    const lockPaths: string[] = [];\n    const releaseLocks: (() => Promise<void>)[] = [];\n\n    try {\n        for (let i = 0; ports.length < count; i++) {\n            const port = start + i;\n            if (port > 65535) {\n                throw new Error(\"Out of ports\");\n            }\n\n            const lockPath = path.join(os.tmpdir(), `mcu-debug-port-${port}.lock`);\n\n            const inUse = await TcpPortScanner.isPortInUse(port, avoid);\n            if (inUse) {\n                if (consecutive) {\n                    throw new Error(`Port ${port} is already in use`);\n                } else {\n                    continue;\n                }\n            }\n\n            try {\n                // Ensure file exists\n                if (!fs.existsSync(lockPath)) {\n                    fs.writeFileSync(lockPath, \"\");\n                }\n\n                const release = await lockfile.lock(lockPath, { stale: 30000 });\n\n                lockPaths.push(lockPath);\n                releaseLocks.push(release);\n                ports.push(port);\n            } catch (e) {\n                if (consecutive) {\n                    throw e;\n                }\n                // If not consecutive, just treat this port as unavailable and continue\n                continue;\n            }\n        }\n\n        return new PortRangeLock(lockPaths, ports);\n    } catch (err) {\n        // Cleanup locks we got\n        try {\n            await Promise.all(releaseLocks.map((r) => r().catch(() => {})));\n        } catch (e: any) {\n            console.error(`Error releasing port locks: ${e.toString()}`);\n        }\n        return null;\n    }\n}\n\nexport async function findAvailablePortRange(count: number, preferredStart: number, consecutive: boolean, avoid: Set<number> | undefined): Promise<PortRangeLock> {\n    for (let base = preferredStart ?? 30000; base < 65535; base += 10) {\n        const result = await tryReserveRange(base, count, consecutive, avoid);\n        if (result) return result;\n    }\n\n    throw new Error(`Could not find ${count} consecutive free ports`);\n}\n\nprocess.on(\"exit\", async () => {\n    for (const lock of allLockFiles) {\n        try {\n            await lock.release();\n        } catch {\n            // Ignore\n        }\n    }\n});\n", "const fs = require(\"fs\");\nconst path = require(\"path\");\nconst process = require(\"process\");\n\nexport function commandExists(commandName: string) {\n    const envPath = process.env.PATH || \"\";\n    // Split the PATH into individual directory paths, considering platform differences\n    const pathDirs = envPath.split(path.delimiter);\n\n    // Define executable extensions for Windows\n    const extensions = process.platform === \"win32\" ? [\".exe\", \".cmd\", \".bat\", \".sh\"] : [\"\"];\n\n    for (const dir of pathDirs) {\n        for (const ext of extensions) {\n            const fullPath = path.join(dir, commandName + ext);\n            try {\n                // Check if the file exists and is executable\n                fs.accessSync(fullPath, fs.constants.F_OK | fs.constants.X_OK);\n                return true; // Command found and is executable\n            } catch (err) {\n                // Command not found or not executable in this specific path/extension combination\n                continue;\n            }\n        }\n    }\n\n    return false; // Command not found anywhere in the PATH\n}\n", "/**\n * Interface for objects that can generate their own unique content-based key.\n */\nexport interface IValueIdentifiable {\n    /**\n     * Returns a string representation that uniquely identifies the value\n     * of this object. (e.g. \"User:123:v1\")\n     */\n    toValueKey(): string;\n}\n\n/**\n * A registry that assigns a unique integer handle to objects based on\n * their structural value (deep equality) rather than reference.\n *\n * Note: Can be Expensive. The default implementation uses a stable\n * JSON.stringify to determine object equality. For better performance,\n * objects can implement IValueIdentifiable to provide their own\n * unique value-based key.\n *\n * Usage:\n *   const registry = new ValueHandleRegistry<MyType>();\n *   const handle = registry.getHandle(myObject);\n *   const sameHandle = registry.getHandle(anotherObjectWithSameValue);\n *   const originalObject = registry.getObject(handle);\n */\n\nexport class ValueHandleRegistry<T = any> {\n    private keyToHandle = new Map<string, number>();\n    private handleToObj = new Map<number, T>();\n    private counter = 0;\n\n    /**\n     * Get a handle for an object. If the object (by value) has been seen before,\n     * returns the existing handle. Otherwise, creates a new one.\n     */\n    public addObject(obj: T): number {\n        const key = this.getKey(obj);\n\n        let handle = this.keyToHandle.get(key);\n        if (handle !== undefined) {\n            return handle;\n        }\n\n        handle = ++this.counter;\n        this.keyToHandle.set(key, handle);\n        this.handleToObj.set(handle, obj);\n        return handle;\n    }\n\n    public getHandle(obj: T): number | undefined {\n        const key = this.getKey(obj);\n        const handle = this.keyToHandle.get(key);\n        return handle;\n    }\n\n    public getObject(handle: number): T | undefined {\n        return this.handleToObj.get(handle);\n    }\n\n    public getObjectByKey(key: T): T | undefined {\n        const handle = this.keyToHandle.get(this.getKey(key));\n        if (handle !== undefined) {\n            return this.handleToObj.get(handle);\n        }\n        return undefined;\n    }\n\n    public release(handle: number): boolean {\n        const obj = this.handleToObj.get(handle);\n        if (!obj) return false;\n\n        const key = this.getKey(obj);\n        this.keyToHandle.delete(key);\n        this.handleToObj.delete(handle);\n        return true;\n    }\n\n    /**\n     * Determines the unique key for an object using the hybrid strategy.\n     */\n    private getKey(obj: any): string {\n        // 1. Optimization: Check if object generates its own key\n        if (isValueIdentifiable(obj)) {\n            return obj.toValueKey();\n        }\n        // 2. Fallback: Structural equality\n        return this.stableStringify(obj);\n    }\n\n    /**\n     * Recursively stringifies an object with sorted keys.\n     * Respects IValueIdentifiable during recursion.\n     */\n    private stableStringify(val: any): string {\n        // Check for Interface deep in the tree\n        if (isValueIdentifiable(val)) {\n            return val.toValueKey();\n        }\n\n        // Primitives / Null\n        if (val === null || typeof val !== \"object\") {\n            return JSON.stringify(val);\n        }\n\n        // Native Types that don't serialize well with Object.keys()\n        if (val instanceof Date) return JSON.stringify(val.toISOString());\n        if (val instanceof RegExp) return JSON.stringify(val.toString());\n\n        // Arrays\n        if (Array.isArray(val)) {\n            return \"[\" + val.map((item) => this.stableStringify(item)).join(\",\") + \"]\";\n        }\n\n        // Objects: Sort keys for determinism\n        const keys = Object.keys(val).sort();\n        const parts = keys.map((key) => {\n            return JSON.stringify(key) + \":\" + this.stableStringify(val[key]);\n        });\n\n        return \"{\" + parts.join(\",\") + \"}\";\n    }\n\n    public clear() {\n        this.keyToHandle.clear();\n        this.handleToObj.clear();\n        this.counter = 0;\n    }\n}\n\n// Type Guard: safely checks if an object implements the interface\nfunction isValueIdentifiable(obj: any): obj is IValueIdentifiable {\n    return obj && typeof obj.toValueKey === \"function\";\n}\n\nexport class ValueHandleRegistryPrimitive<T = string | number | boolean | BigInt> {\n    private keyToHandle = new Map<T, number>();\n    private handleToItem = new Map<number, T>();\n    private counter = 0;\n\n    add(item: T): number {\n        const existing = this.keyToHandle.get(item);\n        if (existing !== undefined) {\n            return existing;\n        }\n        this.counter++;\n        this.keyToHandle.set(item, this.counter);\n        this.handleToItem.set(this.counter, item);\n        return this.counter;\n    }\n\n    get(handle: number): T | undefined {\n        return this.handleToItem.get(handle);\n    }\n\n    release(handle: number): boolean {\n        const obj = this.handleToItem.get(handle);\n        if (!obj) return false;\n\n        this.keyToHandle.delete(obj);\n        this.handleToItem.delete(handle);\n        return true;\n    }\n\n    clear() {\n        this.keyToHandle.clear();\n        this.handleToItem.clear();\n        this.counter = 0;\n    }\n}\n"],
  "mappings": "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",
  "names": ["fs", "path", "os", "net", "lockfile", "EventEmitter", "PortRangeLock", "lockPaths", "ports", "p", "allLockFiles", "TcpPortScanner", "_TcpPortScanner", "port", "avoid", "hosts", "hostsToCheck", "h", "host", "resolve", "reject", "server", "err", "numPorts", "options", "findAvailablePortRange", "lock", "tryReserveRange", "start", "count", "consecutive", "releaseLocks", "i", "lockPath", "release", "e", "r", "preferredStart", "base", "result", "fs", "path", "process", "commandExists", "commandName", "pathDirs", "extensions", "dir", "ext", "fullPath", "ValueHandleRegistry", "obj", "key", "handle", "isValueIdentifiable", "val", "item", "ValueHandleRegistryPrimitive", "existing"]
}
