var b=(n=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(n,{get:(t,r)=>(typeof require<"u"?require:t)[r]}):n)(function(n){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+n+'" is not supported')});import*as h from"fs";import*as w from"path";import*as S from"os";import*as E from"net";import*as p from"proper-lockfile";import{EventEmitter as j}from"events";var g=class{constructor(t,r){this.lockPaths=t;this.ports=r}async release(){await Promise.all(this.lockPaths.map(t=>p.unlock(t).catch(()=>{})))}},y=[],T=class n{static LoopbackAddr="127.0.0.1";static AllInterfaces="0.0.0.0";static PortAllocated=new j;static AvoidPorts=new Set;static EmitAllocated(t){if(t&&t.length){for(let r of t)n.AvoidPorts.add(r);n.PortAllocated.emit("allocated",t)}}static async unlockPortsIfFree(t){for(let r of y)if(r.ports.filter(o=>t.includes(o)).length===r.ports.length)try{await r.release()}catch{}}static async isPortInUse(t,r,s){if(r&&r.has(t))return!0;let o=s&&s.length?s:[n.LoopbackAddr,n.AllInterfaces];for(let e of o)if(await n.checkPortStatus(t,e))return!0;return!1}static checkPortStatus(t,r){return new Promise((s,o)=>{let e=E.createServer(()=>{});e.once("error",i=>{i.code==="EADDRINUSE"?s(!0):o(i)}),e.once("close",()=>{s(!1)}),e.listen(t,r,()=>{e.close()})})}static findFreePorts(t,r={}){return new Promise((s,o)=>{H(t,r.start??3e4,r.consecutive??!1,r.avoid).then(e=>{y.push(e),n.EmitAllocated(e.ports),s(e.ports)}).catch(e=>{o(e)})})}};async function $(n,t,r=!1,s){let o=[],e=[],i=[];try{for(let c=0;o.length<t;c++){let a=n+c;if(a>65535)throw new Error("Out of ports");let u=w.join(S.tmpdir(),`mcu-debug-port-${a}.lock`);if(await T.isPortInUse(a,s)){if(r)throw new Error(`Port ${a} is already in use`);continue}try{h.existsSync(u)||h.writeFileSync(u,"");let l=await p.lock(u,{stale:3e4});e.push(u),i.push(l),o.push(a)}catch(l){if(r)throw l;continue}}return new g(e,o)}catch{try{await Promise.all(i.map(a=>a().catch(()=>{})))}catch(a){console.error(`Error releasing port locks: ${a.toString()}`)}return null}}async function H(n,t,r,s){for(let o=t??3e4;o<65535;o+=10){let e=await $(o,n,r,s);if(e)return e}throw new Error(`Could not find ${n} consecutive free ports`)}process.on("exit",async()=>{for(let n of y)try{await n.release()}catch{}});var P=b("fs"),v=b("path"),O=b("process");function J(n){let r=(O.env.PATH||"").split(v.delimiter),s=O.platform==="win32"?[".exe",".cmd",".bat",".sh"]:[""];for(let o of r)for(let e of s){let i=v.join(o,n+e);try{return P.accessSync(i,P.constants.F_OK|P.constants.X_OK),!0}catch{continue}}return!1}var I=class{keyToHandle=new Map;handleToObj=new Map;counter=0;addObject(t){let r=this.getKey(t),s=this.keyToHandle.get(r);return s!==void 0||(s=++this.counter,this.keyToHandle.set(r,s),this.handleToObj.set(s,t)),s}getHandle(t){let r=this.getKey(t);return this.keyToHandle.get(r)}getObject(t){return this.handleToObj.get(t)}getObjectByKey(t){let r=this.getKey(t),s=this.keyToHandle.get(r);if(s!==void 0)return this.handleToObj.get(s)}release(t){let r=this.handleToObj.get(t);if(!r)return!1;let s=this.getKey(r);return this.keyToHandle.delete(s),this.handleToObj.delete(t),!0}getKey(t){return A(t)?t.toValueKey():this.stableStringify(t)}stableStringify(t){return A(t)?t.toValueKey():t===null||typeof t!="object"?JSON.stringify(t):t instanceof Date?JSON.stringify(t.toISOString()):t instanceof RegExp?JSON.stringify(t.toString()):Array.isArray(t)?"["+t.map(o=>this.stableStringify(o)).join(",")+"]":"{"+Object.keys(t).sort().map(o=>JSON.stringify(o)+":"+this.stableStringify(t[o])).join(",")+"}"}clear(){this.keyToHandle.clear(),this.handleToObj.clear(),this.counter=0}};function A(n){return n&&typeof n.toValueKey=="function"}var C=class{keyToHandle=new Map;handleToItem=new Map;counter=0;add(t){let r=this.keyToHandle.get(t);return r!==void 0?r:(this.counter++,this.keyToHandle.set(t,this.counter),this.handleToItem.set(this.counter,t),this.counter)}get(t){return this.handleToItem.get(t)}release(t){let r=this.handleToItem.get(t);return r?(this.keyToHandle.delete(r),this.handleToItem.delete(t),!0):!1}clear(){this.keyToHandle.clear(),this.handleToItem.clear(),this.counter=0}};import*as f from"net";var R={silent:{setup:()=>{},starting:()=>{},tryConnect:()=>{},connected:()=>{},timeout:()=>{}},verbose:{starting:({host:n,port:t})=>{console.log(`Waiting for ${n}:${t} to become available...`)},setup:n=>{console.log(`Socket created: ${n.remoteAddress}:${n.remotePort}`)},tryConnect:()=>{console.log("Trying to connect...")},connected:n=>{console.log("Connected!")},timeout:()=>{console.log("Timeout reached, giving up.")}}},x=class{constructor(t){this.params=t}IPv6enabled=!0;returnedSocket=!1;createConnectionWithTimeout(t,r,s){let o=null,e={host:this.params.host,port:this.params.port,family:t,autoSelectFamily:!0},i=f.createConnection(e,c=>{if(!c&&o&&(clearTimeout(o),o=null),!this.returnedSocket)return s(c)});return this.params.callbacks.setup?.(i),i.on("error",c=>{o&&(clearTimeout(o),o=null),this.returnedSocket||(i.destroy(),s(c))}),o=setTimeout(()=>{i.destroy();let c=new Error(`Timeout trying to open socket to ${this.params.host}:${this.params.port}, IPv${t}`);c.code="ECONNTIMEOUT",s(c)},r),i}checkHttp(t,r,s,o){let e=`GET ${this.params.path} HTTP/1.1\r
Host: ${this.params.host}\r
\r
`,i=null;i=setTimeout(()=>{t.destroy();let c=new Error(`Timeout waiting for data from ${this.params.host}:${this.params.port}, IPv${r}`);c.code="EREQTIMEOUT",o(c)},s),t.on("data",function(c){let u=c.toString().split(`
`)[0];i&&clearTimeout(i);let d=u.split(" ");if(d.length<2||d[1].startsWith("2")===!1){let l=new Error("Invalid response from server");l.code="ERESPONSE",o(l)}o()}),t.write(e)}tryConnect(t,r){return new Promise((s,o)=>{try{let e=this.createConnectionWithTimeout(t,this.params.interval||1e3,i=>{if(i)return i.code==="ECONNREFUSED"||i.code==="EACCES"?(e.destroy(),s([!1])):i.code==="ECONNTIMEOUT"?(e.destroy(),s([!1])):i.code==="ECONNRESET"?(e.destroy(),s([!1])):this.IPv6enabled===!0&&(i.code==="EADDRNOTAVAIL"||i.code==="ENOTFOUND")?(this.IPv6enabled=!1,e.destroy(),s([!1])):i.code==="ENOTFOUND"?(e.destroy(),this.params.waitForDns===!0?s([!1]):o(new Error(`The address '${this.params.host}' cannot be found`))):(e.destroy(),t===6?(this.IPv6enabled=!1,s([!1])):o(i));if(this.params.protocol!=="http")return s([!0,e]);this.checkHttp(e,t,r,c=>c?c.code==="EREQTIMEOUT"?(e.destroy(),s([!1])):c.code==="ERESPONSE"?(e.destroy(),s([!1])):(e.destroy(),o(c)):s([!0,e]))})}catch(e){return o(e)}})}waitPort(){return this.returnedSocket=!1,this.IPv6enabled=!0,new Promise((t,r)=>{U(this.params);let s=this.params.host,o=this.params.port,e=this.params.interval,i=this.params.timeout,c=new Date,a=1e3,u=this.params.callbacks||R.silent;u.starting({host:s,port:o});let d=(l=4)=>{u.tryConnect?.(),this.tryConnect(l,a).then(([m,k])=>{if(m)return this.returnedSocket=!0,u.connected(k),t({open:!0,ipVersion:l,socket:k});let D=new Date().getTime()-c.getTime();return i&&D>i?(u.timeout(),t({open:!1})):this.IPv6enabled&&l===4&&!f.isIP(s)?d(6):setTimeout(d,e)}).catch(m=>r(m))};d()})}};function U(n){n.protocol=n.protocol||"tcp",n.host=n.host||"127.0.0.1",n.port=n.port||80,n.path=n.path||"/",n.interval=n.interval||1e3,n.timeout=n.timeout||0,n.waitForDns=n.waitForDns||!1}import*as F from"child_process";import{EventEmitter as W}from"events";var N=class extends W{spec;process;constructor(t){super(),this.spec=Object.assign({},t),this.spec.cwd=t.cwd||process.cwd(),this.spec.env={...process.env,...t.env||{}}}getProgram(){return this.spec.program}getArgs(){return this.spec.args}getCwd(){return this.spec.cwd}runProgram(t){return new Promise((r,s)=>{let o={cwd:this.getCwd(),env:this.spec.env,detached:!0};t&&(o.stdio=t),this.process=F.spawn(this.getProgram(),this.getArgs(),o),this.process.stdout?.on("data",e=>{this.emit("stdout",e)}),this.process.stderr?.on("data",e=>{this.emit("stderr",e)}),this.process.on("close",e=>{this.emit("close",e)}),this.process.on("error",e=>{this.emit("error",e),s(e)}),this.process.on("spawn",()=>{r()}),this.on("stdin",async e=>{await this.writeStdin(e)})})}setStdinPiped(t){t.pipe(this.process?.stdin)}setStdoutPiped(t){this.process?.stdout?.pipe(t)}setStderrPiped(t){this.process?.stderr?.pipe(t)}async writeStdin(t){this.process&&this.process.stdin&&this.process.stdin.writable&&(this.process.stdin.write(t)||await this.process.stdin.once("drain",()=>{}))}close(){this.process&&(this.process.stdin?.end(),setTimeout(()=>{this.process?.stdout?.destroy(),this.process?.stderr?.destroy(),this.process?.kill(),this.process=void 0},10))}dispose(){this.close(),this.removeAllListeners()}};export{N as Decoder,T as TcpPortScanner,I as ValueHandleRegistry,C as ValueHandleRegistryPrimitive,x as WaitForPort,J as commandExists,H as findAvailablePortRange};
//# sourceMappingURL=index.mjs.map
